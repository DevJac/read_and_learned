* The Rust Programming Language - Second Edition
* Chapter 3 - Common Programming Concepts
** Variables
- variables are immutable by default
- create new variables with the let keyword: let x = 5;
- create mutable variables with the mut keyword: let mut x = 5;
- variables can be shadowed by new variables with the same name
** Constants
- are always immutable, not just immutable by default like variables
- must have a type annotation
- may only be set to a constant expression, they cannot be assigned the result of a function call
- conventionally, are named in ALL_CAPS with underscores
- constants are valid for the entire time a program runs, within the scope they were declared in
** Scalar vs Compound Types
- scalar represents single values; e.g.: ints, floats, booleans, characters
- compund types combine scalar types; e.g.: tuples, arrays
** Type Annotations
let x: i32 = 10;
let y: (i32, bool) = (10, false);
** Tuples
*** Destructuring
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
*** Index Access
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
** Arrays
- can only contain one type of element
- are allocated on the stack
- elements can be accessed using indexes; use square braces for indexing, like in Python
- bounds checking happens are runtime
** Functions
- declared with the fn keyword
- by convention, are named in snake_case style
- parameters must have type annotations
- those end expression of a function is it's return value
- example:
  fn plus_one(x: i32) -> i32 {
      x + 1
  }
** Statements and Expressions
- assignment is one of the only things that cannot be an expression, only a statement
- if a line ends in a semi-colon, it is a statement
- expressions evaluate (simplify) to a single value
** Comments
- comments begin with //
** if Expressions
- if expressions can be used as expressions (hence the name)
- example:
  fn main() {
      let number = 3;

      if number != 0 {
          println!("number was something other than zero");
      }
  }
- example:
  fn main() {
      let number = 6;

      if number % 4 == 0 {
          println!("number is divisible by 4");
      } else if number % 3 == 0 {
          println!("number is divisible by 3");
      } else if number % 2 == 0 {
          println!("number is divisible by 2");
      } else {
          println!("number is not divisible by 4, 3, or 2");
      }
  }
** Loops
- Rust has 3 loop types: loop, while, for
- can "break" out of loops
- for loop example:
  fn main() {
      let a = [10, 20, 30, 40, 50];

      for element in a.iter() {
          println!("the value is: {}", element);
      }
  }
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
* Chapter 4 - Understanding Ownership
** Ownership
*** The Stack and the Heap
- the stack if a last-in-first-out queue, hence the name "stack"
- all data on the stack must have a known and fixed size
- "allocating" refers to finding room in the heap to store something whose size is only known at runtime
*** Ownership Rules
!. Each value in Rust has a variable that’s called its owner.
2. There can only be one owner at a time.
3. When the owner goes out of scope, the value will be dropped.
*** Example
fn main() {
    let s = String::from("hello");  // s comes into scope.

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here.
    let x = 5;                      // x comes into scope.

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward.

} // Here, x goes out of scope, then s. But since s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope.
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope.
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
*** Example 2
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1.

    let s2 = String::from("hello");     // s2 comes into scope.

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3.
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it.

    let some_string = String::from("hello"); // some_string comes into scope.

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function.
}

// takes_and_gives_back will take a String and return one.
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope.

    a_string  // a_string is returned and moves out to the calling function.
}
** References and Borrowing
*** Rules
- At any time you may have one mutable reference OR infinite immutable references
- The owner of a value must not drop while there are still references
*** Immutable Reference Example
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
*** Mutable Reference Example
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
** Slices
*** String Slice Example
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
*** Array Slice Example
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
*** String literals are slices
Functions should usually take &str instead of &String, because &String can be easily turned into &str by slicing the whole string.
