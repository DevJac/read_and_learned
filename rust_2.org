* The Rust Programming Language - Second Edition
* Chapter 3 - Common Programming Concepts
** Variables
- variables are immutable by default
- create new variables with the let keyword: let x = 5;
- create mutable variables with the mut keyword: let mut x = 5;
- variables can be shadowed by new variables with the same name
** Constants
- are always immutable, not just immutable by default like variables
- must have a type annotation
- may only be set to a constant expression, they cannot be assigned the result of a function call
- conventionally, are named in ALL_CAPS with underscores
- constants are valid for the entire time a program runs, within the scope they were declared in
** Scalar vs Compound Types
- scalar represents single values; e.g.: ints, floats, booleans, characters
- compund types combine scalar types; e.g.: tuples, arrays
** Type Annotations
let x: i32 = 10;
let y: (i32, bool) = (10, false);
** Tuples
*** Destructuring
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
*** Index Access
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
** Arrays
- can only contain one type of element
- are allocated on the stack
- elements can be accessed using indexes; use square braces for indexing, like in Python
- bounds checking happens are runtime
** Functions
- declared with the fn keyword
- by convention, are named in snake_case style
- parameters must have type annotations
- those end expression of a function is it's return value
- example:
  fn plus_one(x: i32) -> i32 {
      x + 1
  }
** Statements and Expressions
- assignment is one of the only things that cannot be an expression, only a statement
- if a line ends in a semi-colon, it is a statement
- expressions evaluate (simplify) to a single value
** Comments
- comments begin with //
** if Expressions
- if expressions can be used as expressions (hence the name)
- example:
  fn main() {
      let number = 3;

      if number != 0 {
          println!("number was something other than zero");
      }
  }
- example:
  fn main() {
      let number = 6;

      if number % 4 == 0 {
          println!("number is divisible by 4");
      } else if number % 3 == 0 {
          println!("number is divisible by 3");
      } else if number % 2 == 0 {
          println!("number is divisible by 2");
      } else {
          println!("number is not divisible by 4, 3, or 2");
      }
  }
** Loops
- Rust has 3 loop types: loop, while, for
- can "break" out of loops
- for loop example:
  fn main() {
      let a = [10, 20, 30, 40, 50];

      for element in a.iter() {
          println!("the value is: {}", element);
      }
  }
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
* Chapter 4 - Understanding Ownership
** Ownership
*** The Stack and the Heap
- the stack if a last-in-first-out queue, hence the name "stack"
- all data on the stack must have a known and fixed size
- "allocating" refers to finding room in the heap to store something whose size is only known at runtime
*** Ownership Rules
!. Each value in Rust has a variable that’s called its owner.
2. There can only be one owner at a time.
3. When the owner goes out of scope, the value will be dropped.
*** Example
fn main() {
    let s = String::from("hello");  // s comes into scope.

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here.
    let x = 5;                      // x comes into scope.

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward.

} // Here, x goes out of scope, then s. But since s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope.
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope.
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
*** Example 2
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1.

    let s2 = String::from("hello");     // s2 comes into scope.

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3.
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it.

    let some_string = String::from("hello"); // some_string comes into scope.

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function.
}

// takes_and_gives_back will take a String and return one.
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope.

    a_string  // a_string is returned and moves out to the calling function.
}
** References and Borrowing
*** Rules
- At any time you may have one mutable reference OR infinite immutable references
- The owner of a value must not drop while there are still references
*** Immutable Reference Example
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
*** Mutable Reference Example
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
** Slices
*** String Slice Example
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
*** Array Slice Example
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
*** String literals are slices
Functions should usually take &str instead of &String, because &String can be easily turned into &str by slicing the whole string.
* Chapter 5 - Structs
- struct is short for structure
- they are sort of like a named tuple
- it's possible for a struct to store references, but this requires lifetimes
** Struct example:
struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.length * rectangle.width
}
** Printing and Debugging Structs
- use {:?} or {:#?} to print structs with println!
*** Example:
#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!("rect1 is {:?}", rect1);
}
** Struct Methods Example:
#[derive(Debug)]
struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.length * self.width
    }
}

fn main() {
    let rect1 = Rectangle { length: 50, width: 30 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );

    // This is an associated function.
    // Notice it does not have a self parameter.
    fn square(size: u32) -> Rectangle {
        Rectangle { length: size, width: size }
    }
}
* Chapter 6 - Enums and Pattern Matching
- enum is short for enumeration
- enums are similar to algebraic data types (ADTs)
** Enum Example:
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
** Option<T> Example:
let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None;
** Match Example:
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
** Match can have guards:
This is an example of a clause in a match which has a guard: Err(ref error) if error.kind() == ErrorKind::NotFound => {...
** if let
If you write a match that only takes action on a single value, and then uses a wildcard for the rest of the values, consider using an if let statement.
*** Example:
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) => println!("three"),
    _ => (),
}

Above is equivalent to:

if let Some(3) = some_u8_value {
    println!("three");
}
// You can also have an else clause in if let statements.
* Chapter 7 - Modules
- mod.rs acts like __init__.py in Python modules
- modules can be declared in src/lib.rs, but defined in another file
- the use keyword can help with long namespace name
- extern crate is required to access functions (etc) from another crate
- a project is considered to be 2 separate crates rooted at src/main.rs and src/lib.rs
- modules and functions (etc) are private by default
* Chapter 8 - Common Collections
** TODO Read chapter 8
* Chapter 9 - Error Handling
** Panic vs abort
Panic will cause the stack to unwind, and for cleanups to happen. You can abort instead to instantly end the process and let the OS cleanup. Configuring Rust/Cargo to use abort can lead to smaller binaries.
** unwrap and expect
unwrap and expect can be used on Results if you just want to panic on the Err condition.
** ? syntax
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

can be shortened to

    let mut f = File::open("hello.txt")?;

Notice the ?
** To panic or not to panic
- In examples, prototypes, and tests, go ahead and panic.
- Consider marking areas where you panic for ease of implementation, so they can be improved later.
- Sometimes you know something will never fail, go ahead and unwrap then. If you'd feel comfortable using an assert, then you could also use an unwrap.
* Chapter 10 - Generic Types, Traits, and Lifetimes
** TODO Read chapter 10
